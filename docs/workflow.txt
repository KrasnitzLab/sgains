#Input for the full pipeline:
#	Generic name for the reference genome (e.g., hg, mm, dm): 
#	genome=hg
#	Name for the specific build of the reference genome (e.g., hg38):
#	genomebuild=hg19
#	Directory containing the reference genome (*.fastq files)
#	Expected read length (e.g., 100, 150): 
#	readlength=100
# Desired number of bins (e.g., 5000)
# Directory containing unmapped read data (*.fastq or *.fastq.gz files;
#		one file per well for single-end data, two files per well for paired-end
#		data)
#	Guide table, listing for each cell/well, its ID, sector, gate
#	Segmentation parameters (default values: alpha = 0.05, nperm = 1000, 
#		undo.SD = 1.0, min.width = 5)
#	Maximal allowed fraction of the genome with copy number 0 (homoloss; it is not
#		clear how it is implemented in the package; suggested default value 0.01)
#	Parameters to construct the feature table: smear (default 1), 
#		keepboundaries (default FALSE)
# Parameters to compute observed and simulated Fisher p-values: nsim (default 
#		500), 
#	Parameters to compute false discovery rate: lm_max (default 0.001)
# Parameters to determine clones and sub-clones: as listed in function calls
#		to find_clone and find_sub_clone below; for simplicity, identically-named
#		parameters should have the same value for both function calls
#	subcloneTooBig, a parameter required to generate the clone table for the 
#		Viewer (default 0.8)
#		

## Let us punt for now on how we build & use hybrid genomes. We cannot
## do everything at once. But, keeping this in mind, we can define 2 separate
## shell variables, genome (e.g., hg, mm, dm) and genomebuild (e.g., hg38)

## mask pseudoautosomal regions and build index
Rscript --vanilla chrYmask.R $genomebuild
bash build.index.bash

## Simulation for mappable regions

# parameters: read length, e.g. 100; genome, e.g. hg or hgdm
#a generic directory name

mkdir readsim	#this must be a host directory!
#The R script issues system calls to invoke as many instances of Bowtie as there
#are cores assigned to the container (caution: an instance of Bowtie may require
#	> 2Gb of memory).
Rscript --vanilla mappableRegions.R $genome $readlength
cat readsim/*.txt > mappable.regions.txt
sort -k 1,1 -k 2,2n mappable.regions.txt > mappable.regions.sorted.txt
python chrom.mappable.bowtie.py
python chrom.sizes.py . $genome
python bin.boundaries.py $bincount 2> bin.boundaries.stderr
#Is this sorting necessary with the above version of bin.boundaries.py?
sort -k 3,3n bin.boundaries.bowtie.txt > bin.boundaries.bowtie.sorted.txt
python varbin.gc.content.bowtie.py > varbin.gc.content.bowtie.stdout 2> varbin.gc.content.bowtie.stderr

## prepare SAM files for each cell in one directory
/filepath/cellSAMdir
#bowtie -S -t -n 2 -e 200 --chunkmbs 256 -3 18 -5 8 -m 1 --best --strata --solexa-quals $genomebuild \
    <(gunzip -c raw/s_2_1_sequence.txt.gz | head -n 5000000 | \
    python adapter.clip02.py GATCGGAAGAGCGG) | \
    samtools view -Sbu -o paa0001.bam -
Rscript --vanilla $rawextension




# After obtaining the mappable regions, all the following procedures till the input files for viewer are

# implemented in R package.



################ R ############ 

library(SCclust)

chromFa_dir <- "/filepath/ChromFa"

k100_dir <- "/filepath/ChromFa/k100"



## determine bin boundaries

bin_boundaries(k100_dir, bincount = 20000)


## Compute GC content

varbinGC(chromFa_dir, k100_dir, Nk = "20k")

## compute bin counts
SAM_dir <- "/filepath/cellSAMdir"

cellname <- "CJA1023"

bin_counts(SAM_dir,k100_dir, cellname, Nk = "20k")



## GC normalization and segmentation for bin counts of all cells

segfile <- cbs.segment_all(input_file_dir = SAM_dir,

                           alpha = 0.05, nperm = 1000, undo.SD = 1.0, min.width = 5)

seg.quantal <- segfile$seg.quantal

ratio.quantal <- segfile$ratio.quantal

Alternatively, for each single cell: 

bin_mat_normalized <- gc_one(bin_mat, gc)

bin_mat_segmented <- cbs.segment_one(bin_mat_normalized, alpha = 0.05, nperm = 1000, undo.SD = 1.0, min.width = 5)



## pins, pinmat
res1 <- preprocess_segfile(seg.quantal, gc, eviltwins = c("CJA1024", "CJA1025"), ploidies = TRUE)
breakpoint_table <- res1$breakpoint_table
ploidies_table <- res1$ploidies_table
smear_table <- findsmears(breakpoint_table, smear = 1, keepboundaries = FALSE, mask_XY = TRUE)

res2 <- findpins(breakpoint_table, smear_table)
pins <- res2$pins
pinmat <- res2$pinmat
cell_names <- res2$cell_names

## hclust, clone identification
res3 <- simFisher_parallel(pins, pinmat, sim_round = 500)
true_fisherPV <- res3$true_fisherPV
sim_fisherPV <- res3$sim_fisherPV

res4 <- fdr_fisherPV(true_fisherPV, sim_fisherPV, cell_names, lm_max = 0.001, graphic = FALSE)
mat_fdr <- res4$mat_fdr
mat_dist <- res4$mat_dist

hc <- hclust_tree(pinmat, mat_fdr, mat_dist, hc_method = "average")
hc_clone <- find_clone(hc, fdr_thresh = -2, share_min = 0.85, n_share = 3, bymax = TRUE,
                       climb_from_size = 2, climb_to_share = 3, graphic = FALSE)

## subclone identification
sub_hc_clone <- find_subclone(hc_clone, pinmat, pins, min_node_size = 6, sim_round = 500,
                              lm_max = 0.001, hc_method = "average",base_share = 3,
                              fdr_thresh = -2, share_min = 0.90, bymax = TRUE, climb_from_size = 2,
                              climb_to_share = 3, graphic = FALSE)

## generate the output files for viewer
output_viewer(output_file_dir = "/filepath/viewerInput",
              seg.quantal, ratio.quantal, pins, pinmat, mat_dist, hc_clone,
              sub_hc_clone, subcloneTooBig = 0.8, smear = 1, study="GL9.2")
